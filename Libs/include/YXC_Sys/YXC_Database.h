/* ****************************************************************************** *\

Author : Qiushi Yuan
Copyright(c) 2008-2015 Qiushi Yuan. All Rights Reserved.
This software is supplied under the terms, you cannot copy or disclose except agreement with the author. 

\* ****************************************************************************** */
#ifndef __INC_YXC_SYS_BASE_DATABASE_H__
#define __INC_YXC_SYS_BASE_DATABASE_H__

#include <YXC_Sys/YXC_Sys.h>

#define YXC_DB_MAX_COLS 128
#define YXC_DB_MAX_COL_NAME 64

#define YXC_DB_DATA_TYPE_I8 0
#define YXC_DB_DATA_TYPE_I16 1
#define YXC_DB_DATA_TYPE_I32 2
#define YXC_DB_DATA_TYPE_I64 3
#define YXC_DB_DATA_TYPE_U8 4
#define YXC_DB_DATA_TYPE_U16 5
#define YXC_DB_DATA_TYPE_U32 6
#define YXC_DB_DATA_TYPE_U64 7
#define YXC_DB_DATA_TYPE_BIT 8
#define YXC_DB_DATA_TYPE_F32 9
#define YXC_DB_DATA_TYPE_F64 10
#define YXC_DB_DATA_TYPE_ASTRING 11
#define YXC_DB_DATA_TYPE_VASTRING 12
#define YXC_DB_DATA_TYPE_LVASTRING 13
#define YXC_DB_DATA_TYPE_WSTRING 14
#define YXC_DB_DATA_TYPE_VWSTRING 15
#define YXC_DB_DATA_TYPE_LVWSTRING 16
#define YXC_DB_DATA_TYPE_BINARY 17
#define YXC_DB_DATA_TYPE_VBINARY 18
#define YXC_DB_DATA_TYPE_LVBINARY 19
#define YXC_DB_DATA_TYPE_DATE 20
#define YXC_DB_DATA_TYPE_TIME 21
#define YXC_DB_DATA_TYPE_TIMESTAMP 22
#define YXC_DB_DATA_TYPE_DATETIME 23

#define YXC_DB_DEF_TRANS_LEN 2048

#define YXC_DB_DATA_TYPE_MAX (YXC_DB_DATA_TYPE_DATETIME + 1)

#define YXC_DB_NULL_DATA (-1)

#if YCHAR_WCHAR_T
#define YXC_DB_DATA_TYPE_LVSTRING YXC_DB_DATA_TYPE_LVWSTRING
#define YXC_DB_DATA_TYPE_VSTRING YXC_DB_DATA_TYPE_VWSTRING
#define YXC_DB_DATA_TYPE_STRING YXC_DB_DATA_TYPE_VSTRING
#else
#define YXC_DB_DATA_TYPE_LVSTRING YXC_DB_DATA_TYPE_LVASTRING
#define YXC_DB_DATA_TYPE_VSTRING YXC_DB_DATA_TYPE_VASTRING
#define YXC_DB_DATA_TYPE_STRING YXC_DB_DATA_TYPE_VSTRING
#endif /* YCHAR_WCHAR_T */

#ifdef __cplusplus
extern "C"
{
#endif /* __cplusplus */

	/** \struct YXC_DBConn
	 * \brief A type of database connection handle.
	 */
	YXC_DECLARE_STRUCTURE_HANDLE(YXC_DBConn);

	/** \struct YXC_DBStat
	 * \brief A type of database statement handle.
	 */
	YXC_DECLARE_STRUCTURE_HANDLE(YXC_DBStat);

	/**
	 * \brief An enumeration witch identifies the database connection type.
	 */
	typedef enum __YXC_DB_CONNECTION_TYPE
	{
		YXC_DB_CONNECTION_TYPE_UNKNOWN = 0, /**< Unknown connection type, default value. */
		YXC_DB_CONNECTION_TYPE_MSSQL, /**< Use Connection by Microsoft ODBC driver. */
		YXC_DB_CONNECTION_TYPE_MYSQL, /**< Use Connection by mysql client dll, not supported now. */
		YXC_DB_CONNECTION_TYPE_ORACLE, /**< Use Connection by orcale client dll, not supported now. */
		YXC_DB_CONNECTION_TYPE_SQLITE3, /**< Use Connection by sqlite3. */
	}YXC_DBConnType;

	/** \brief A structure of a result set column header(generated by select statement). */
	typedef struct __YXC_DB_RESULT_TABLE_COLUMN_HEADER
	{
		/** The column can be null or not. */
		ybool_t bCanBeNull;

		/** The data type of the column. */
		ybyte_t byDataType;

		/** The max data len, in bytes, defined by the column. */
		yuint32_t uDataMaxLen;

		/** The column's display name. */
		wchar_t szColName[YXC_DB_MAX_COL_NAME];
	}YXC_DBRTColHeader;

	/** \brief A structure of a column-binding info to a result set. Used to bind to a select result set and data fetching. */
	typedef struct __YXC_DB_RESULT_TABLE_COL_BIND_INFO
	{
		/** The buffer size of binding info, you should fill with zero when you don't know or don't care. */
		yuint32_t uBufferSize;

		/** The memory to bind with, NULL for the buffer will be dynamic allocated by YXC system. */
		void* pMemory;

		/** The column binding type. This type should be equal to the real type which is stored by database. */
		ybyte_t byDataType;
	}YXC_DBRTColBindInfo;

	/** \brief A structure of the result cell data. */
	typedef struct __YXC_DB_RESULT_TABLE_CELL
	{
		/** This value of the cell is NULL or not. */
		ybool_t bIsNullVal;

		/** The result data length, in bytes, of the cell. */
		yuint32_t uDataLen;

		/** The buffer length, in bytes, of this cell. */
		yuint32_t uBufferLen;

		/** The data pointer of the cell. You can only use this to read the cell value when the cell is not NULL(\b bIsNullVal is FALSE).
		 *  Otherwise, its content is undefined.
		 */
		void* pCellData;
	}YXC_DBRTCell;

	/**
	 * \brief Create a database connection by a specified connection type.
	 * \param[in]  connType      Specify the connection type to use. Can be one of the valid value of ::YXC_DBConnType enumeration
	 * \param[in]  bAutoCommit   Put this parameter to TRUE when you need to do commit immediately after your operations. Otherwise, put it to false.
	 *                              Default value should be TRUE.
	 * \param[out] pDbc          A pointer of ::YXC_DBConn to receive the returned database connection handle.
	 * \return                   A status code of YXC system, ::YXC_ERC_SUCCESS for operation successful. Otherwise, this operation is failed
	 *                               and you can call YXC_GetLastError() for help.
	 * \return                   Once ::YXC_ERC_SUCCESS code is returned, the handle is created and you should close this connection use YXC_DBConnClose()
	 *                               when you don't use this connection. Otherwise, the connection is not created and undefined,
	 *                               so don't call any function by this connection.
	 * \warning                  This function is not thread safe.
	 * \see        YXC_DBConnClose
	 * \see        YXC_DBConnConnect
	 * \see        YXC_DBConnAllocStatement
	 */
	YXC_API(YXC_Status) YXC_DBConnCreate(YXC_DBConnType connType, ybool_t bAutoCommit, YXC_DBConn* pDbc);

	/**
	 * \brief Close an opened database connection.
	 * \param[in] dbc    The database connection handle to close.
	 * \warning          This function is not thread safe.
	 * \see       YXC_DBConnCreate
	 */
	YXC_API(void) YXC_DBConnClose(YXC_DBConn dbc);

	/**
	 * \brief Process connecting to remote database server. The connection timeout is set to 5 seconds now.
	 * \param[in] dbc          The database connection handle.
	 * \param[in] cpszTarget   The remote database identifier, can be an ip address, or a computer name.
	 * \param[in] uTargetPort  The remote database port.
	 * \param[in] cpszDriver   The database driver to use.
	 * \param[in] cpszInitDB   The initialize database to use.
	 * \param[in] cpszUser     The username used to connect to the database server.
	 * \param[in] cpszPwd      The password used to connect to the database server.
	 * \return                 A status code of YXC system, ::YXC_ERC_SUCCESS for operation successful. Otherwise, this operation is failed
	 *                             and you can call YXC_GetLastError() for help.
	 * \warning                This function is not thread safe.
	 * \see       YXC_DBConnCreate
	 */
	YXC_API(YXC_Status) YXC_DBConnConnect(YXC_DBConn dbc, const wchar_t* cpszTarget, yuint32_t uTargetPort,
		const wchar_t* cpszDriver, const wchar_t* cpszInitDB, const wchar_t* cpszUser, const wchar_t* cpszPwd);

	/**
	 * \brief Allocate a database statement for sql command execution.
	 * \param[in]  dbc      The input database connection handle.
	 * \param[out] pDbs     A pointer of ::YXC_DBStat to receive the returned database statement handle.
	 * \return              A status code of YXC system, ::YXC_ERC_SUCCESS for operation successful. Otherwise, this operation is failed
	 *                          and you can call YXC_GetLastError() for help.
	 * \return              Once ::YXC_ERC_SUCCESS code is returned, the handle is created and you should close this statement use YXC_DBConnFreeStatement()
	 *                          when you don't use this statement. Otherwise, the statement is not created and undefined,
	 *                          so don't call any function by this statement.
	 * \attention                You should call YXC_DBConnConnect() before allocate any statement handle.
	 * \warning             This function is not thread safe.
	 * \see        YXC_DBConnCreate
	 * \see        YXC_DBConnConnect
	 * \see        YXC_DBConnFreeStatement
	 */
	YXC_API(YXC_Status) YXC_DBConnAllocStatement(YXC_DBConn dbc, YXC_DBStat* pDbs);

	/**
	 * \brief Free a database statement.
	 * \param[in] dbc     The database connection handle from which the statement allocated.
	 * \param[in] dbs     The database statement handle to be freed.
	 * \warning           This function is not thread safe.
	 * \see       YXC_DBConnAllocStatement
	 */
	YXC_API(void) YXC_DBConnFreeStatement(YXC_DBConn dbc, YXC_DBStat dbs);

	// Convert sql ; SELECT 'ab'c' -> SELECT 'ab''c'
	// YXC_API(YXC_Status) YXC_DBQueryExact(YXC_DBConn dbc, wchar_t* cpszStatement, ysize_t stStatLen);

	// YXC_API(void) YXC_DBMemFree(void* pMem);

	/**
	 * \brief Prepare a sql command to be executed.
	 * \param[in] dbs       The database statement handle.
	 * \param[in] cpszPrep  The sql command.
	 * \return              A status code of YXC system, ::YXC_ERC_SUCCESS for operation successful. Otherwise, this operation is failed
	 *                         and you can call YXC_GetLastError() for help.
	 * \attention                You can call YXC_DBStatExecute() to really execute the commands.
	 * \warning             This function is not thread safe.
	 * \see       YXC_DBConnAllocStatement
	 * \see       YXC_DBConnCreate
	 * \see       YXC_DBStatExecute
	 */
	YXC_API(YXC_Status) YXC_DBStatPrepare(YXC_DBStat dbs, const wchar_t* cpszPrep);

	/**
	 * \brief End a transaction with commit or rollback.
	 * \param[in] dbs     The database statement handle.
	 * \param[in] bCommit Commit or rollback this transaction.
	 * \warning           This function is not thread safe.
	 * \see       YXC_DBConnConnect
	 */
	YXC_API(YXC_Status) YXC_DBStatEndTrans(YXC_DBStat dbs, ybool_t bCommit);

	/** \brief Bind an input parameter to database statement.
	 * \param[in] dbs        The database statement handle.
	 * \param[in] byDataType The data type of the parameter.
	 * \param[in] uColIndex  The index of the parameter to be bound in statement, start at 0.
	 * \param[in] stColDef   The column special description of this parameter.
	 * \param[in] pstDataLen The pointer to the size, in bytes, of the data to be bound. You can fill ::YXC_DB_NULL_DATA for bind NULL data.
	 * \param[in] pData      The data pointer of the parameter to be bound in statement.
	 * \return               A status code of YXC system, ::YXC_ERC_SUCCESS for operation successful. Otherwise, this operation is failed
	 *                          and you can call YXC_GetLastError() for help.
	 * \attention                 The pointer of parameter pstDataLen must be valid when YXC_DBStatExecute() is called.
	 * \warning              This function is not thread safe.
	 * \see       YXC_DBConnAllocStatement
	 * \see       YXC_DBConnCreate
	 * \see       YXC_DBStatResetParams
	 * \see       YXC_DBStatBindOutputParam
	 */
	YXC_API(YXC_Status) YXC_DBStatBindInputParam(YXC_DBStat dbs, ybyte_t byDataType, yuint32_t uColIndex, yssize_t* pstDataLen, const void* pData);

	/** \brief Bind an output parameter to database statement.
	 * \param[in] dbs        The database statement handle.
	 * \param[in] byDataType The data type of the parameter.
	 * \param[in] uColIndex  The index of the parameter to be bound in statement, start at 0.
	 * \param[in] stColDef   The column special description of this parameter.
	 * \param[in] pstDataLen The pointer to the size, in bytes, of the data to be bound. You can fill ::YXC_DB_NULL_DATA for bind NULL data.
	 * \param[in] pData      The data pointer of the parameter to be bound in statement.
	 * \return               A status code of YXC system, ::YXC_ERC_SUCCESS for operation successful. Otherwise, this operation is failed
	 *                          and you can call YXC_GetLastError() for help.
	 * \attention                 The pointer of parameter pstDataLen must be valid when YXC_DBStatExecute() is called.
	 * \warning              This function is not thread safe.
	 * \see       YXC_DBConnAllocStatement
	 * \see       YXC_DBConnCreate
	 * \see       YXC_DBStatResetParams
	 * \see       YXC_DBStatBindInputParam
	 */
	YXC_API(YXC_Status) YXC_DBStatBindOutputParam(YXC_DBStat dbs, ybyte_t byDataType, yuint32_t uColIndex, yssize_t* pstDataLen, void* pData);

	/**
	 * \brief Execute the prepared sql command.
	 * \param[in]  dbs              The database statement handle.
	 * \param[out] pstAffectedRows  The pointer to a number to receive number of rows affected by the sql query, can be NULL.
	 * \return                      A status code of YXC system, ::YXC_ERC_SUCCESS for operation successful. Otherwise, this operation is failed
	 *                                 and you can call YXC_GetLastError() for help.
	 * \return                      Once this procedure successful and the statement is a SELECT statement,
	 *                                  you must call YXC_DBStatCloseCursor() before any other command execution.
	 * \warning                     This function is not thread safe.
	 * \see        YXC_DBConnAllocStatement
	 * \see        YXC_DBConnCreate
	 * \see        YXC_DBStatPrepare
	 */
	YXC_API(YXC_Status) YXC_DBStatExecute(YXC_DBStat dbs, ysize_t* pstAffectedRows);

	/**
	 * \brief Move to next sql statement result.
	 * \param[in]  dbs              The database statement handle.
	 * \param[out] pstAffectedRows  The pointer to a number to receive number of rows affected by the sql query, can be NULL.
	 * \return                      A status code of YXC system, ::YXC_ERC_SUCCESS for operation successful. Otherwise, this operation is failed
	 *                                 and you can call YXC_GetLastError() for help.
	 * \return                      Once this procedure successful and the statement is a SELECT statement,
	 *                                  you must call YXC_DBStatCloseCursor() before any other command execution.
	 * \warning                     This function is not thread safe.
	 * \see        YXC_DBConnAllocStatement
	 * \see        YXC_DBStatExecute
	 * \see        YXC_DBStatPrepare
	 */
	YXC_API(YXC_Status) YXC_DBStatNextResult(YXC_DBStat dbs, ysize_t* pstAffectedRows);

	/**
	 * \brief Reset all the parameters bound in the statement.
	 * \param[in] dbs        The database statement handle to reset bound parameters.
	 * \return               A status code of YXC system, ::YXC_ERC_SUCCESS for operation successful. Otherwise, this operation is failed
	 *                          and you can call YXC_GetLastError() for help.
	 * \warning              This function is not thread safe.
	 * \see       YXC_DBStatExecute
	 * \see       YXC_DBStatBindInputParam
	 * \see       YXC_DBStatBindOutputParam
	 */
	YXC_API(YXC_Status) YXC_DBStatResetParams(YXC_DBStat dbs);

	/**
	 * \brief Execute a sql command directly.
	 * \param[in]  dbs              The database statement handle.
	 * \param[in]  cpszStmt         The sql command to be executed.
	 * \param[out] pstAffectedRows  The pointer to a number to receive number of rows affected by the sql query, can be NULL.
	 * \return                      A status code of YXC system, ::YXC_ERC_SUCCESS for operation successful. Otherwise, this operation is failed
	 *                                  and you can call YXC_GetLastError() for help.
	 * \return                      Once ::YXC_ERC_SUCCESS is returned and the statement is a SELECT statement,
	 *                                  you must call YXC_DBStatCloseCursor() for other command execution.
	 * \warning                     This function is not thread safe.
	 * \see        YXC_DBStatExecute
	 */
	YXC_API(YXC_Status) YXC_DBStatExecDirect(YXC_DBStat dbs, const wchar_t* cpszStmt, ysize_t* pstAffectedRows);

	/**
	 * \brief Close the database statement result set cursor. Must be called after successful execution of SELECT statement.
	 * \param[in] dbs    The database statement handle.
	 * \return           A status code of YXC system, ::YXC_ERC_SUCCESS for operation successful. Otherwise, this operation is failed
	 *                       and you can call YXC_GetLastError() for help.
	 * \warning          This function is not thread safe.
	 * \see       YXC_DBStatExecute
	 * \see       YXC_DBStatExecDirect
	 */
	YXC_API(YXC_Status) YXC_DBStatCloseCursor(YXC_DBStat dbs);

	/**
	 * \brief Query the result set information.
	 * \param[in]     dbs           The database statement handle.
	 * \param[in,out] puNumHeaders  The pointer to the number buffer of columns, in count, of the \b pHeaders parameter,
	                                and will receive actual number of columns after function call.
	 * \param[out]    pHeaders      The pointer to buffers of the ::YXC_DBRTColHeader structure, which size is determined by parameter \b puNumHeaders.
	 * \return                      A status code of YXC system, ::YXC_ERC_SUCCESS for operation successful. Otherwise, this operation is failed
	 *                                  and you can call YXC_GetLastError() for help.
	 * \attention                        This function call must before any function calls to YXC_DBStatCloseCursor().
	 * \warning                     This function is not thread safe.
	 * \see           YXC_DBStatExecute
	 */
	YXC_API(YXC_Status) YXC_DBStatQueryResultInfo(YXC_DBStat dbs, yuint32_t* puNumHeaders, YXC_DBRTColHeader* pHeaders);

	/**
	 * \brief Bind the col bind memories to the result set.
	 * \param[in]  dbs          The database statement handle.
	 * \param[in]  uNumColumns  Number of columns to bind. To get the actual column number of the result set, call YXC_DBStatQueryResultInfo().
	 * \param[in]  pBindInfos   The array of bind infos, its count is determined by parameter \b uNumColumns.
	 * \param[out] ppCellsPtr   The pointer to receive a result cells pointer array.
	 * \return                  A status code of YXC system, ::YXC_ERC_SUCCESS for operation successful. Otherwise, this operation is failed
	 *                              and you can call YXC_GetLastError() for help.
	 * \attention                    This function call must before any function calls to YXC_DBStatCloseCursor().
	 * \attention                    You can modify the binding infos by calling YXC_DBStatBindMemory() again or call YXC_DBStatRebindCol()
	 *                              to rebind a single column.
	 * \warning    This function is not thread safe.
	 * \see        YXC_DBStatExecute
	 * \see        YXC_DBStatFetchNextRow
	 * \see        YXC_DBStatFetchRow
	 * \see        YXC_DBStatRebindCol
	 */
	YXC_API(YXC_Status) YXC_DBStatBindMemory(YXC_DBStat dbs, yuint32_t uNumColumns, const YXC_DBRTColBindInfo* pBindInfos,
		const YXC_DBRTCell** ppCellsPtr);

	/**
	 * \brief Fetch the next row to buffer from result set.
	 * \param[in] dbs          The database statement handle.
	 * \return                 A status code of YXC system, ::YXC_ERC_SUCCESS for operation successful. Otherwise, this operation is failed
	 *                             and you can call YXC_GetLastError() for help.
	 * \attention                   The memory buffer pointers is specified by an ::YXC_DBRTCell pointer,
	 *                             which you can receive by a previous call of YXC_DBStatBindMemory().
	 *                             \b pCellsPtr[0] identifies the first cell of the current row fetched, etc.
	 *                             And number of columns can be obtained both by call YXC_DBStatQueryResultInfo() and by your SELECT statement.
	 * \attention                   This function call must before any function calls to YXC_DBStatCloseCursor().
	 * \warning                This function is not thread safe.
	 * \see       YXC_DBStatRefetchCurrentRow
	 * \see       YXC_DBStatBindMemory
	 */
	YXC_API(YXC_Status) YXC_DBStatFetchNextRow(YXC_DBStat dbs);

	/**
	 * \brief Re-fetch current row data.
	 * \param[in] dbs          The database statement handle.
	 * \return                 A status code of YXC system, ::YXC_ERC_SUCCESS for operation successful. Otherwise, this operation is failed
	 *                             and you can call YXC_GetLastError() for help.
	 * \attention                   The memory buffer pointers is specified by an ::YXC_DBRTCell pointer,
	 *                             which you can receive by a previous call of YXC_DBStatBindMemory().
	 *                             \b pCellsPtr[0] identifies the first cell of the current row fetched, etc.
	 *                             And number of columns can be obtained both by call YXC_DBStatQueryResultInfo() and by your SELECT statement.
	 * \attention                   This function call must before any function calls to YXC_DBStatCloseCursor().
	 * \warning                This function is not thread safe.
	 * \see       YXC_DBStatFetchNextRow
	 * \see       YXC_DBStatBindMemory
	 */
	YXC_API(YXC_Status) YXC_DBStatRefetchCurrentRow(YXC_DBStat dbs);

	/**
	 * \brief Rebind a column-binding info to database statement.
	 * \param[in]  dbs          The database statement handle.
	 * \param[in]  uColIndex    The index of column to be rebound.
	 * \param[in]  pBindInfo    The new binding info of the column.
	 * \return                  A status code of YXC system, ::YXC_ERC_SUCCESS for operation successful. Otherwise, this operation is failed
	 *                              and you can call YXC_GetLastError() for help.
	 * \attention                    This function call must occur after one or more calls to YXC_DBStatBindMemory().
	 * \warning    This function is not thread safe.
	 * \see        YXC_DBStatExecute
	 * \see        YXC_DBStatFetchNextRow
	 * \see        YXC_DBStatFetchRow
	 * \see        YXC_DBStatBindMemory
	 */
	YXC_API(YXC_Status) YXC_DBStatRebindCol(YXC_DBStat dbs, yuint32_t uColIndex, const YXC_DBRTColBindInfo* pBindInfo);

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* __INC_YXC_SYS_BASE_DATABASE_H__ */
